{"version":3,"sources":["thump/core.cljc"],"mappings":";AAIA,6BAAA,7BAAMA,kEAAcC;AAApB,AACE,IAAMC,QAAM,AAACC,oBAAUF;IACjBG,UAAQ,AAACC,eAAKJ;AADpB,AAEE,GAAI,UAAA,TAAMC;AACRE;;AAEA,cAAA,NAAKF,UAAUE;;;AAErB,wCAAA,xCAAgBM,wFAAkBC,GAAGC,MAAMC;AAA3C,AAAA,OAAAP,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,6EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,QAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,WAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,cAAA,KAAA,IAAA,/JACsBE,8FAAIC,+CAAOC;;AAEjC,AAAA,AAEA,+BAAA,/BAAMC,sEAAmBC;AAAzB,AACE,GAAI,AAACC,wBAAQD;AACX,QAACE,iDAAAA,oDAAAA,LAAMF,gCAAAA;;AACPA;;;AAEJ,mBAAA,nBAAME,8CAAOC;AAAb,AACE,GAAA,GAAQ,AAACF,wBAAQE;AACf,MAAO,6IAAA,7IAACC,gDAAQ,kDAAA,LAAKD;;AACrB,IAAAE,aAA4BF;IAA5BG,aAAA,AAAAd,cAAAa;IAAAE,eAAA,AAAAC,gBAAAF;IAAAA,iBAAA,AAAAG,eAAAH;SAAAC,LAAOX;IAAPW,mBAAA,AAAAC,gBAAAF;IAAAA,iBAAA,AAAAG,eAAAH;YAAAC,RAAUV;eAAVS,XAAkBR;IAGZF,SAAG,EAAI,eAAAc,dAAUd,kCAAI,AAACX,2BAAaW,IAAIA;IACvCe,eAAO,AAACC,qBAAKf;IACbgB,kBAAU,GAAK,4BAAA,3BAAM,AAACrB,cAAIM;IAC1BA,eAAS,kDAAA,kDAAA,gBAAA,AAAA,qBAAA,vIACE,EAAKa,kBAAOE,mBAAWf,WACvBe,iBAAU,AAACC,eAAKjB,MAAMC,YACtBa,mCACK,KAAAjB,eAAA,WAAA,KAAA,IAAA,fAAMG;;IACtBA,YAAM,sBAAA,pBAAIc,cACFd;AAZd,AAcE,OAACF,gDAAiBC,OAAGC,UAAM,AAACkB,4CAAIhB,6BAAkBD;;;AAKxD,uBAAA,vBAAMkB,sDAAWb;AAAjB,AACE,OAACD,iBAAMC;;AAGN,AAAI,sCAAA,AAAA,tCAACc,gHAAiDf;;AAClD,sCAAA,AAAA,tCAACe,2FAAsCf","names":["thump.core/keyword->str","k","kw-ns","cljs.core/namespace","kw-name","cljs.core/name","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","thump.core/*hiccup-element*","el","props","children","thump.core/maybe-parse-child","c","cljs.core/vector?","thump.core/parse","vec","cljs.core.ex_info","vec__45226","seq__45227","first__45228","cljs.core/first","cljs.core/next","cljs.core/Keyword","props?","cljs.core/map?","children?","cljs.core/cons","cljs.core.map","thump.core/interpret","cljs.reader/register-tag-parser!"],"sourcesContent":["(ns thump.core\n  #?(:cljs (:require [cljs.reader]))\n  (:refer-clojure :exclude [compile]))\n\n(defn keyword->str [k]\n  (let [kw-ns (namespace k)\n        kw-name (name k)]\n    (if (nil? kw-ns)\n      kw-name\n\n      (str kw-ns \"/\" kw-name))))\n\n(defn ^:dynamic *hiccup-element* [el props children]\n  `(~'hiccup-element ~el ~props ~children))\n\n(declare parse)\n\n(defn maybe-parse-child [c]\n  (if (vector? c)\n    (parse c)\n    c))\n\n(defn parse [vec]\n  (if-not (vector? vec)\n    (throw (ex-info (str vec \" is not a valid hiccup vector.\") {}))\n    (let [[el props & children] vec\n\n          ;; parse\n          el (if (keyword? el) (keyword->str el) el)\n          props? (map? props)\n          children? (not (nil? (seq children)))\n          children (cond\n                     (and props? children?) children\n                     children? (cons props children)\n                     props? '()\n                     true (list props))\n          props (if props?\n                  props\n                  nil)]\n      (*hiccup-element* el props (map maybe-parse-child children)))))\n\n(defmacro compile [vec]\n  (parse vec))\n\n(defn interpret [vec]\n  (parse vec))\n\n#?(:cljs\n   (do (cljs.reader/register-tag-parser! 'hiccup/element parse)\n       (cljs.reader/register-tag-parser! 'h/e parse)))\n"]}